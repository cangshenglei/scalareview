函数式编程和面向对象编程同样属于编程思想概念。区别在于函数式编程思想的抽象程度更高。

.1.1 函数基本语法
 定义函数的关键字   函数名  ( 参数名:函数类型.... ) 函数返回值类型 ={
          函数体
 }

  函数和方法的区别
 1）核心概念
 （1）为完成某一功能的程序语句的集合，称为函数。
 （2）类中的函数称之方法。
 2）案例实操
 （1）Scala语言可以在任何的语法结构中声明任何的语法
 （2）函数没有重载和重写的概念；方法可以进行重载和重写
 （3）Scala中函数可以嵌套定义


 5.1.3 函数参数
 1）案例实操
 （1）可变参数
 （2）如果参数列表中存在多个参数，那么可变参数一般放置在最后
 （3）参数默认值，一般将有默认值的参数放置在参数列表的后面
 （4）带名参数


 函数至简原则（重点）
函数至简原则：能省则省
1）至简原则细节
	常用化简写法：
（1）return可以省略，Scala会使用函数体的最后一行代码作为返回值
（2）如果函数体只有一行代码，可以省略花括号
（3）返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）
特别注意事项：
（4）如果有return，则不能省略返回值类型，必须指定
（5）如果函数明确声明unit，那么即使函数体中使用return关键字也不起作用
（6）Scala如果期望是无返回值类型，可以省略等号
（7）如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加
（8）如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略
修改为匿名函数：
（9）如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略



5.1.5 匿名函数化简
1）说明
没有名字的函数就是匿名函数。
(x:Int)=>{函数体}
x：表示输入参数类型；Int：表示输入参数类型；函数体：表示具体代码逻辑
2）案例实操
	需求1：传递的函数有一个参数
传递匿名函数至简原则：
（1）参数的类型可以省略，会根据形参进行自动的推导
（2）类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过1的永远不能省略圆括号。
（3）匿名函数如果只有一行，则大括号也可以省略
（4）如果参数只出现一次，且按照顺序出现则参数省略且后面参数可以用_代替
不能化简为下划线的情况： 1.化简之后只有一个下划线  2.化简后的函数存在嵌套


函数高级
5.2.1 高阶函数
在Scala中，函数是一等公民。怎么体现的呢？
对于一个函数我们可以：定义函数、调用函数。

函数还有更高阶的用法
（1）函数可以作为值进行传递
（2）函数可以作为参数进行传递
（3）函数可以作为函数返回值返回



函数柯里化&闭包
闭包：函数式编程的标配
1）说明
闭包：如果一个函数，访问到了它的外部（局部）变量的值，那么这个函数和他所处的环境，称为闭包。
函数柯里化：把一个参数列表的多个参数，变成多个参数列表。


递归
1）说明
	一个函数/方法在函数/方法体内又调用了本身，我们称之为递归调用。


   // 递归
    // 1. 调用自身
    // 2. 跳出条件
    // 3. 填入的参数必须有规律
    // 4. 递归必须声明函数返回值类型

    // 尾递归优化
    @tailrec
    def rec1(n: Int, res: Int = 1): Int = {
	if (n == 1) res else rec1(n - 1,res * n)
    }

控制抽象
1）值调用：把计算后的值传递过去
2）名调用：把代码传递过去


惰性函数
1）说明
当函数返回值被声明为lazy时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行。这种函数我们称之为惰性函数。

注意：lazy不能修饰var类型的变量。




在Scala中可以为每个包定义一个同名的包对象，定义在包对象中的成员，作为其对应包下所有class和object的共享变量，可以被直接访问。


import com.atguigu.Fruit	引入com.atguigu包下Fruit（class和object）
import com.atguigu._	引入com.atguigu下的所有成员
import com.atguigu.Fruit._	引入Fruit(object)的所有成员
import com.atguigu.{Fruit,Vegetable}	引入com.atguigu下的Fruit和Vegetable
import com.atguigu.{Fruit=>Shuiguo}	引入com.atguigu包下的Fruit并更名为Shuiguo
import com.atguigu.{Fruit=>Shuiguo,_}	引入com.atguigu包下的所有成员，并将Fruit更名为Shuiguo
import com.atguigu.{Fruit=>_,_}	引入com.atguigu包下屏蔽Fruit类
new _root_.java.util.HashMap	引入的Java的绝对路径
2）补充
Scala中的三个默认导入分别是
import java.lang._
import scala._
import scala.Predef._
注意scala._是包含scala.Predef._，但是两者有区别，前者是导入scala包里面的所有类和对象，后者是导入Predef伴生对象中的所有属性和方法（等同于静态属性和方法）。



类：可以看成一个模板
对象：表示具体的事物
6.2.1 定义类
0）回顾：Java中的类
	如果类是public的，则必须和文件名一致。
	一般，一个.java有一个public类
注意：Scala中没有public，一个.scala中可以写多个类。
1）基本语法
[修饰符] class 类名 {
    类体
}
说明
（1）Scala语法中，类并不声明为public，所有这些类都具有公有可见性（即默认就是public）
（2）一个Scala源文件可以包含多个类




//（1）Scala语法中，类并不声明为public，所有这些类都具有公有可见性（即默认就是public）
//（2）一个Scala源文件可以包含多个类




 属性和封装
属性是类的一个组成部分。
封装就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作（成员方法），才能对数据进行操作。Java封装操作如下，
（1）将属性进行私有化
（2）提供一个公共的set方法，用于对属性赋值
（3）提供一个公共的get方法，用于获取属性的值
Scala中的public属性，底层实际为private，并通过get方法（obj.field()）和set方法（obj.field_=(value)）对其进行操作。所以Scala并不推荐将属性设为private，再为其设置public的get和set方法的做法。但由于很多Java框架都利用反射调用getXXX和setXXX方法，有时候为了和这些框架兼容，也会为Scala的属性设置getXXX和setXXX方法（通过@BeanProperty注解实现）。
1）基本语法
[修饰符] var|val 属性名称 [：类型] = 属性值
注：Bean属性（@BeanPropetry），可以自动生成规范的setXxx/getXxx方法


访问权限
1）说明
在Java中，访问权限分为：public， protected，默认,和private 。在Scala中，你可以通过类似的修饰符达到同样的效果。但是使用上有区别。
（1）Scala 中属性和方法的默认访问权限为public，但Scala中无public关键字。
（2）private为私有权限，只在类的内部和伴生对象中可用。
（3）protected为受保护权限，Scala中受保护权限比Java中更严格，同类、子类可以访问，同包无法访问。
（4）private[包名]增加包访问权限，包名下的其他类也可以使用


方法
1）基本语法
def 方法名(参数列表) [：返回值类型] = {
	方法体
}

构造器
和Java一样，Scala构造对象也需要调用构造方法，并且可以有任意多个构造方法。
Scala类的构造器包括：主构造器和辅助构造器
1）基本语法
class 类名(形参列表) {  // 主构造器
   // 类体
   def  this(形参列表) {  // 辅助构造器
   }
   def  this(形参列表) {  //辅助构造器可以有多个...
   }
}
说明：
（1）辅助构造器，函数的名称this，可以有多个，编译器通过参数的个数及类型来区分。
（2）辅助构造方法不能直接构建对象，必须直接或者间接调用主构造方法。
（3）构造器调用其他另外的构造器，要求被调用构造器必须提前声明。
2）案例实操
（1）如果主构造器无参数，小括号可省略，构建对象时调用的构造方法的小括号也可以省略。


// 主构造器  直接写在类的定义后面  可以添加参数  可以使用权限修饰符
//class Person06 private(name:String){
//  val name1 = name
//}

class Person06 (name:String){
  println("调用主构造器")

  val name1 = name
  var age:Int = _

  // 两个辅助构造器  再互相调用的时候 只能是下面的辅助构造器调用上面的辅助构造器

  def this(){
    // 辅助构造器的第一行 必须直接或简介的调用主构造器
    // 直接调用主构造器
    this("zhangsan")
    println("调用辅助构造器1")
  }

  def this(name:String,age1:Int){
    // 间接调用主构造器
    this()
    this.age = age1
    println("调用辅助构造器2")
  }


构造器参数
1）说明
Scala类的主构造器函数的形参包括三种类型：未用任何修饰、var修饰、val修饰
（1）未用任何修饰符修饰，这个参数就是一个局部变量，底层有属性的特性
（2）var修饰参数，作为类的成员属性使用，可以修改
（3）val修饰参数，作为类只读属性使用，不能修改

// 主构造器参数 分为3类:
// 没有修饰符 : 作为构造方法中的传入参数使用
// val 修饰 : 会自动生产同名的属性 并且定义为val
// var 修饰 : 会自动生产同名的属性 并且定义为var
class Person07 (name1:String,val age:Int,var sex:String){
  	val name = name1
	//  val age = age
	//  var sex = sex
}


基本语法
scala中的继承本质上是继承一个父类的构造器。


抽象属性和抽象方法
6.4.1 抽象属性和抽象方法
1）基本语法
	（1）定义抽象类：abstract class Person{} //通过abstract关键字标记抽象类
	（2）定义抽象属性：val|var name:String //一个属性没有初始化，就是抽象属性
	（3）定义抽象方法：def  hello():String //只声明而没有实现的方法，就是抽象方法


继承&重写
（1）如果父类为抽象类，那么子类需要将抽象的属性和方法实现，否则子类也需声明为抽象类
（2）重写非抽象方法需要用override修饰，重写抽象方法则可以不加override。
（3）子类中调用父类的方法使用super关键字
（4）子类对抽象属性进行实现，父类抽象属性可以用var修饰；
子类对非抽象属性重写，父类非抽象属性只支持val类型，而不支持var。
因为var修饰的为可变变量，子类继承之后就可以直接使用，没有必要重写








































































































